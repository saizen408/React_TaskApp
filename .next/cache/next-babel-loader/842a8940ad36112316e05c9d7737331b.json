{"ast":null,"code":"import _Object$defineProperty from \"@babel/runtime-corejs2/core-js/object/define-property\";\nimport _Object$defineProperties from \"@babel/runtime-corejs2/core-js/object/define-properties\";\nimport _Object$getOwnPropertyDescriptors from \"@babel/runtime-corejs2/core-js/object/get-own-property-descriptors\";\nimport _Object$getOwnPropertyDescriptor from \"@babel/runtime-corejs2/core-js/object/get-own-property-descriptor\";\nimport _Object$getOwnPropertySymbols from \"@babel/runtime-corejs2/core-js/object/get-own-property-symbols\";\nimport _Object$keys from \"@babel/runtime-corejs2/core-js/object/keys\";\nimport _defineProperty from \"@babel/runtime-corejs2/helpers/esm/defineProperty\";\nvar __jsx = React.createElement;\n\nfunction ownKeys(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (_Object$getOwnPropertyDescriptors) { _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport React, { PureComponent } from \"react\";\nimport DraggableTodoList from \"./DraggableTodoList\";\nimport { withSortedContext } from \"./contexts/SortedContext\";\nimport { withCookies, Cookies } from \"react-cookie\";\nconst cookies = new Cookies();\nimport uuid from \"uuid/v4\";\n\nclass TodoList extends PureComponent {\n  constructor(props) {\n    super(props);\n\n    _defineProperty(this, \"onSortEnd\", ({\n      oldIndex,\n      newIndex\n    }) => {\n      const {\n        tasks,\n        prevArr\n      } = this.state;\n      console.log(\"before sort: \", prevArr);\n\n      if (prevArr.length === 0) {\n        var arr = cookies.get(\"tasks\"); //if prevArr is same size as state.tasks change nothing\n      } else if (prevArr.length === tasks.length) {\n        var arr = prevArr; //if prev arr is smaller than state.tasks push the new element to the end\n      } else if (prevArr.length < tasks.length) {\n        this.setState({\n          prevArr: [...prevArr, tasks[tasks.length - 1]]\n        });\n        var arr = prevArr; //if prev arr is larger than state.tasks filter out the corresponding element\n      } else if (prevArr.length > tasks.length) {\n        this.setState({\n          prevArr: prevArr.filter(task => task._id !== tasks._id)\n        });\n        var arr = prevArr;\n      } else {\n        return console.log(\"something did not go quite as planned with sorting...\");\n      }\n\n      arr = arr.slice();\n      arr.splice(newIndex < 0 ? arr.length + newIndex : newIndex, 0, arr.splice(oldIndex, 1)[0]);\n      console.log(\"after sort: \", arr);\n      this.setState({\n        tasks: arr,\n        prevArr: arr\n      }, cookies.set(\"tasks\", this.state.tasks), console.log(\"ping!!!\"), this.props.sortedContext.updateState = false);\n    });\n\n    this.state = {\n      tasks: cookies.get(\"tasks\") || props.posts,\n      prevArr: []\n    };\n  }\n\n  componentDidUpdate(prevState) {\n    if (prevState.tasks !== this.state.tasks) {\n      console.log(\"comp did update, set tasks!\");\n      cookies.set(\"tasks\", this.state.tasks);\n    } // if (this.state.tasks.length === 1) {\n    //   let firstId = cookies.get(\"taskId\");\n    //   let fakeobj = {\n    //     _id: firstId,\n    //     description: this.state.tasks[0].description,\n    //     completed: this.state.tasks[0].completed,\n    //     updatedAt: this.state.tasks[0].updatedAt\n    //   };\n    //   this.setState({ tasks: fakeobj });\n    // }\n\n  } // shouldComponentUpdate()\n\n\n  static getDerivedStateFromProps(props, state) {\n    if (props.sortedContext.updateState) {\n      props.sortedContext.updateState = false;\n      const {\n        type,\n        id,\n        todo\n      } = props.sortedContext.type;\n      console.log(\"props.sortedContext: \", id);\n      const {\n        tasks\n      } = state; // const taskId = cookies.get(\"taskId\");\n      // cookies.set(\"tasks\", tasks);\n\n      switch (type) {\n        case \"ADD\":\n          return {\n            tasks: [...tasks, {\n              _id: id,\n              description: todo,\n              completed: false\n            }]\n          };\n          break;\n\n        case \"REMOVE\":\n          return {\n            tasks: tasks.filter(task => task._id !== id)\n          };\n        //should refer to state\n\n        case \"TOGGLE\":\n          return {\n            tasks: tasks.map(task => task._id === id ? _objectSpread({}, task, {\n              completed: !task.completed\n            }) : task //should refer to state\n            )\n          };\n          break;\n\n        case \"EDIT\":\n          return {\n            tasks: tasks.map(task => task._id === id ? _objectSpread({}, task, {\n              description: todo\n            }) : task)\n          };\n          break;\n\n        default:\n          return null;\n      }\n    } else return null;\n  } // componentWillReceiveProps(props) {\n  //   if (this.props.posts !== props.posts) {\n  //     this.setState({ newProps: this.props.posts });\n  //   }\n  // }\n\n\n  render() {\n    const {\n      resetSort\n    } = this.props.sortedContext;\n    const {\n      posts\n    } = this.props;\n    const {\n      tasks\n    } = this.state;\n    if (tasks.length) return __jsx(DraggableTodoList, {\n      axis: \"y\",\n      distance: 20,\n      onSortEnd: this.onSortEnd,\n      posts: tasks,\n      tasksDB: posts,\n      sorted: resetSort\n    });\n    return null;\n  }\n\n}\n\nexport default withCookies(withSortedContext(TodoList));","map":null,"metadata":{},"sourceType":"module"}