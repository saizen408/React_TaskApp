{"ast":null,"code":"import _Object$defineProperty from \"@babel/runtime-corejs2/core-js/object/define-property\";\nimport _Object$defineProperties from \"@babel/runtime-corejs2/core-js/object/define-properties\";\nimport _Object$getOwnPropertyDescriptors from \"@babel/runtime-corejs2/core-js/object/get-own-property-descriptors\";\nimport _Object$getOwnPropertyDescriptor from \"@babel/runtime-corejs2/core-js/object/get-own-property-descriptor\";\nimport _Object$getOwnPropertySymbols from \"@babel/runtime-corejs2/core-js/object/get-own-property-symbols\";\nimport _Object$keys from \"@babel/runtime-corejs2/core-js/object/keys\";\nimport _defineProperty from \"@babel/runtime-corejs2/helpers/esm/defineProperty\";\nvar __jsx = React.createElement;\n\nfunction ownKeys(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (_Object$getOwnPropertyDescriptors) { _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport React, { Component } from \"react\";\nimport DraggableTodoList from \"./DraggableTodoList\";\nimport { withSortedContext } from \"./contexts/SortedContext\";\nimport { Cookies } from \"react-cookie\";\nconst cookies = new Cookies();\n\nclass TodoList extends Component {\n  constructor(props) {\n    super(props);\n\n    _defineProperty(this, \"onSortEnd\", ({\n      oldIndex,\n      newIndex\n    }) => {\n      console.log(\"before sort: \", this.state.prevArr);\n\n      if (this.state.prevArr.length === 0) {\n        var arr = this.props.posts; //if prevArr is same size as state.tasks change nothing\n      } else if (this.state.prevArr.length === this.state.tasks.length) {\n        var arr = this.state.prevArr; //when a new task is added ..it's not reflected in prevArr...duh!\n        //if prev arr is smaller than state.tasks push the new element to the end\n      } else if (this.state.prevArr.length < this.state.tasks.length) {\n        this.setState({\n          prevArr: [...this.state.prevArr, this.state.tasks[this.state.tasks.length - 1]]\n        });\n        var arr = this.state.prevArr; //if prev arr is larger than state.tasks filter out the corresponding element\n      } else if (this.state.prevArr.length > this.state.tasks.length) {\n        this.setState({\n          prevArr: this.state.prevArr.filter(task => task._id !== this.props.sortedContext._id)\n        });\n        var arr = this.state.prevArr;\n      } else {\n        return console.log(\"something did not go quite as planned...\");\n      }\n\n      arr = arr.slice();\n      arr.splice(newIndex < 0 ? arr.length + newIndex : newIndex, 0, arr.splice(oldIndex, 1)[0]);\n      console.log(\"after sort: \", arr);\n      this.setState({\n        tasks: arr,\n        prevArr: arr // set a cookie here\n        // sorted: true\n\n      });\n    });\n\n    this.state = {\n      tasks: props.posts,\n      prevArr: [],\n      sorted: false\n    };\n  }\n\n  //component did mount\n  componentDidUpdate() {\n    cookies.set(\"tasks\", this.state.tasks);\n  } // static getDerivedStateFromProps(props, state) {\n  //   //consider component did update\n  //   if (!state.sorted || props.sortedContext.isSorted) {\n  //     if (props.posts.length !== state.tasks.length) {\n  //       return { tasks: props.posts }; //probably should set to something else like state.tasks or state.prevArr...\n  //     }\n  //     for (let i = 0; i < state.tasks.length; i++) {\n  //       if (props.posts[i].completed === !state.tasks[i].completed) {\n  //         return { tasks: props.posts };\n  //       }\n  //       if (props.posts[i].description !== state.tasks[i].description) {\n  //         return { tasks: props.posts };\n  //       }\n  //     }\n  //     return null;\n  //   } else return null;\n  // }\n\n\n  static getDerivedStateFromProps(props, state) {\n    // if (!state.sorted || props.sortedContext.isSorted) {\n    const {\n      type,\n      id,\n      todo,\n      completed\n    } = props.sortedContext.type;\n    const {\n      tasks\n    } = state;\n\n    switch (type) {\n      case \"ADD\":\n        return {\n          tasks: [...tasks, {\n            _id: id,\n            description: todo,\n            completed: false\n          }]\n        };\n        break;\n\n      case \"REMOVE\":\n        return {\n          tasks: tasks.filter(task => task._id !== id)\n        };\n\n      case \"TOGGLE\":\n        return {\n          tasks: tasks.map(task => task._id === id ? _objectSpread({}, task, {\n            completed: !task.completed\n          }) : task)\n        };\n        break;\n\n      case \"EDIT\":\n        return {\n          tasks: tasks.map(task => task._id === id ? _objectSpread({}, task, {\n            description: todo\n          }) : task)\n        };\n        break;\n\n      default:\n        return {\n          tasks: tasks\n        };\n    } // } else return null;\n\n  }\n\n  render() {\n    // console.log(\"this.state.sorted: \", this.state.sorted);\n    const {\n      resetSort\n    } = this.props.sortedContext;\n    const {\n      tasks\n    } = this.state;\n    if (tasks.length) return __jsx(DraggableTodoList, {\n      axis: \"y\",\n      distance: 20,\n      onSortEnd: this.onSortEnd,\n      posts: tasks,\n      sorted: resetSort\n    });\n    return null;\n  }\n\n}\n\nexport default withSortedContext(TodoList);","map":{"version":3,"sources":["/Users/ericowusu/Documents/React _Course_Projects/Next/first-next/components/TodoList.js"],"names":["React","Component","DraggableTodoList","withSortedContext","Cookies","cookies","TodoList","constructor","props","oldIndex","newIndex","console","log","state","prevArr","length","arr","posts","tasks","setState","filter","task","_id","sortedContext","slice","splice","sorted","componentDidUpdate","set","getDerivedStateFromProps","type","id","todo","completed","description","map","render","resetSort","onSortEnd"],"mappings":"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","sourcesContent":["import React, { Component } from \"react\";\nimport DraggableTodoList from \"./DraggableTodoList\";\nimport { withSortedContext } from \"./contexts/SortedContext\";\nimport { Cookies } from \"react-cookie\";\nconst cookies = new Cookies();\n\nclass TodoList extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      tasks: props.posts,\n      prevArr: [],\n      sorted: false\n    };\n  }\n\n  onSortEnd = ({ oldIndex, newIndex }) => {\n    console.log(\"before sort: \", this.state.prevArr);\n    if (this.state.prevArr.length === 0) {\n      var arr = this.props.posts;\n      //if prevArr is same size as state.tasks change nothing\n    } else if (this.state.prevArr.length === this.state.tasks.length) {\n      var arr = this.state.prevArr; //when a new task is added ..it's not reflected in prevArr...duh!\n\n      //if prev arr is smaller than state.tasks push the new element to the end\n    } else if (this.state.prevArr.length < this.state.tasks.length) {\n      this.setState({\n        prevArr: [\n          ...this.state.prevArr,\n          this.state.tasks[this.state.tasks.length - 1]\n        ]\n      });\n      var arr = this.state.prevArr;\n\n      //if prev arr is larger than state.tasks filter out the corresponding element\n    } else if (this.state.prevArr.length > this.state.tasks.length) {\n      this.setState({\n        prevArr: this.state.prevArr.filter(\n          task => task._id !== this.props.sortedContext._id\n        )\n      });\n      var arr = this.state.prevArr;\n    } else {\n      return console.log(\"something did not go quite as planned...\");\n    }\n\n    arr = arr.slice();\n    arr.splice(\n      newIndex < 0 ? arr.length + newIndex : newIndex,\n      0,\n      arr.splice(oldIndex, 1)[0]\n    );\n    console.log(\"after sort: \", arr);\n    this.setState({\n      tasks: arr,\n      prevArr: arr\n      // set a cookie here\n\n      // sorted: true\n    });\n  };\n\n  //component did mount\n  componentDidUpdate() {\n    cookies.set(\"tasks\", this.state.tasks);\n  }\n\n  // static getDerivedStateFromProps(props, state) {\n  //   //consider component did update\n  //   if (!state.sorted || props.sortedContext.isSorted) {\n  //     if (props.posts.length !== state.tasks.length) {\n  //       return { tasks: props.posts }; //probably should set to something else like state.tasks or state.prevArr...\n  //     }\n  //     for (let i = 0; i < state.tasks.length; i++) {\n  //       if (props.posts[i].completed === !state.tasks[i].completed) {\n  //         return { tasks: props.posts };\n  //       }\n  //       if (props.posts[i].description !== state.tasks[i].description) {\n  //         return { tasks: props.posts };\n  //       }\n  //     }\n  //     return null;\n  //   } else return null;\n  // }\n  static getDerivedStateFromProps(props, state) {\n    // if (!state.sorted || props.sortedContext.isSorted) {\n    const { type, id, todo, completed } = props.sortedContext.type;\n    const { tasks } = state;\n\n    switch (type) {\n      case \"ADD\":\n        return {\n          tasks: [...tasks, { _id: id, description: todo, completed: false }]\n        };\n        break;\n      case \"REMOVE\":\n        return { tasks: tasks.filter(task => task._id !== id) };\n      case \"TOGGLE\":\n        return {\n          tasks: tasks.map(task =>\n            task._id === id ? { ...task, completed: !task.completed } : task\n          )\n        };\n        break;\n      case \"EDIT\":\n        return {\n          tasks: tasks.map(task =>\n            task._id === id ? { ...task, description: todo } : task\n          )\n        };\n        break;\n      default:\n        return { tasks: tasks };\n    }\n    // } else return null;\n  }\n\n  render() {\n    // console.log(\"this.state.sorted: \", this.state.sorted);\n    const { resetSort } = this.props.sortedContext;\n    const { tasks } = this.state;\n    if (tasks.length)\n      return (\n        <DraggableTodoList\n          axis=\"y\"\n          distance={20}\n          onSortEnd={this.onSortEnd}\n          posts={tasks}\n          sorted={resetSort}\n        ></DraggableTodoList>\n      );\n    return null;\n  }\n}\n\nexport default withSortedContext(TodoList);\n"]},"metadata":{},"sourceType":"module"}