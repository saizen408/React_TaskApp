{"ast":null,"code":"import _Object$defineProperty from \"@babel/runtime-corejs2/core-js/object/define-property\";\nimport _Object$defineProperties from \"@babel/runtime-corejs2/core-js/object/define-properties\";\nimport _Object$getOwnPropertyDescriptors from \"@babel/runtime-corejs2/core-js/object/get-own-property-descriptors\";\nimport _Object$getOwnPropertyDescriptor from \"@babel/runtime-corejs2/core-js/object/get-own-property-descriptor\";\nimport _Object$getOwnPropertySymbols from \"@babel/runtime-corejs2/core-js/object/get-own-property-symbols\";\nimport _Object$keys from \"@babel/runtime-corejs2/core-js/object/keys\";\nimport _toConsumableArray from \"@babel/runtime-corejs2/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"@babel/runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime-corejs2/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _assertThisInitialized from \"@babel/runtime-corejs2/helpers/esm/assertThisInitialized\";\nimport _inherits from \"@babel/runtime-corejs2/helpers/esm/inherits\";\nimport _defineProperty from \"@babel/runtime-corejs2/helpers/esm/defineProperty\";\nvar __jsx = React.createElement;\n\nfunction ownKeys(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (_Object$getOwnPropertyDescriptors) { _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport React, { PureComponent } from \"react\";\nimport DraggableTodoList from \"./DraggableTodoList\";\nimport { withSortedContext } from \"./contexts/SortedContext\";\nimport { withCookies, Cookies } from \"react-cookie\";\nvar cookies = new Cookies();\nimport uuid from \"uuid/v4\";\n\nvar TodoList =\n/*#__PURE__*/\nfunction (_PureComponent) {\n  _inherits(TodoList, _PureComponent);\n\n  function TodoList(props) {\n    var _this;\n\n    _classCallCheck(this, TodoList);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(TodoList).call(this, props));\n\n    _defineProperty(_assertThisInitialized(_this), \"onSortEnd\", function (_ref) {\n      var oldIndex = _ref.oldIndex,\n          newIndex = _ref.newIndex;\n      var _this$state = _this.state,\n          tasks = _this$state.tasks,\n          prevArr = _this$state.prevArr;\n      console.log(\"before sort: \", prevArr);\n\n      if (prevArr.length === 0) {\n        var arr = cookies.get(\"tasks\"); //if prevArr is same size as state.tasks change nothing\n      } else if (prevArr.length === tasks.length) {\n        var arr = prevArr; //if prev arr is smaller than state.tasks push the new element to the end\n      } else if (prevArr.length < tasks.length) {\n        _this.setState({\n          prevArr: [].concat(_toConsumableArray(prevArr), [tasks[tasks.length - 1]])\n        });\n\n        var arr = prevArr; //if prev arr is larger than state.tasks filter out the corresponding element\n      } else if (prevArr.length > tasks.length) {\n        _this.setState({\n          prevArr: prevArr.filter(function (task) {\n            return task._id !== tasks._id;\n          })\n        });\n\n        var arr = prevArr;\n      } else {\n        return console.log(\"something did not go quite as planned with sorting...\");\n      }\n\n      arr = arr.slice();\n      arr.splice(newIndex < 0 ? arr.length + newIndex : newIndex, 0, arr.splice(oldIndex, 1)[0]);\n      console.log(\"after sort: \", arr);\n\n      _this.setState({\n        tasks: arr,\n        prevArr: arr\n      }, cookies.set(\"tasks\", _this.state.tasks), console.log(\"ping!!!\"), _this.props.sortedContext.updateState = false);\n    });\n\n    _this.state = {\n      tasks: cookies.get(\"tasks\") || props.posts,\n      prevArr: []\n    };\n    return _this;\n  }\n\n  _createClass(TodoList, [{\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevState) {\n      if (prevState.tasks !== this.state.tasks) {\n        console.log(\"comp did update, set tasks!\");\n        cookies.set(\"tasks\", this.state.tasks);\n      } // if (this.state.tasks.length === 1) {\n      //   let firstId = cookies.get(\"taskId\");\n      //   let fakeobj = {\n      //     _id: firstId,\n      //     description: this.state.tasks[0].description,\n      //     completed: this.state.tasks[0].completed,\n      //     updatedAt: this.state.tasks[0].updatedAt\n      //   };\n      //   this.setState({ tasks: fakeobj });\n      // }\n\n    } // shouldComponentUpdate()\n\n  }, {\n    key: \"render\",\n    // componentWillReceiveProps(props) {\n    //   if (this.props.posts !== props.posts) {\n    //     this.setState({ newProps: this.props.posts });\n    //   }\n    // }\n    value: function render() {\n      var resetSort = this.props.sortedContext.resetSort;\n      var posts = this.props.posts;\n      var tasks = this.state.tasks;\n      if (tasks.length) return __jsx(DraggableTodoList, {\n        axis: \"y\",\n        distance: 20,\n        onSortEnd: this.onSortEnd,\n        posts: tasks,\n        tasksDB: posts,\n        sorted: resetSort\n      });\n      return null;\n    }\n  }], [{\n    key: \"getDerivedStateFromProps\",\n    value: function getDerivedStateFromProps(props, state) {\n      if (props.sortedContext.updateState) {\n        props.sortedContext.updateState = false;\n        var _props$sortedContext$ = props.sortedContext.type,\n            type = _props$sortedContext$.type,\n            id = _props$sortedContext$.id,\n            todo = _props$sortedContext$.todo;\n        console.log(\"props.sortedContext: \", id);\n        var tasks = state.tasks; // const taskId = cookies.get(\"taskId\");\n        // cookies.set(\"tasks\", tasks);\n\n        switch (type) {\n          case \"ADD\":\n            return {\n              tasks: [].concat(_toConsumableArray(tasks), [{\n                _id: id,\n                description: todo,\n                completed: false\n              }])\n            };\n            break;\n\n          case \"REMOVE\":\n            return {\n              tasks: tasks.filter(function (task) {\n                return task._id !== id;\n              })\n            };\n          //should refer to state\n\n          case \"TOGGLE\":\n            return {\n              tasks: tasks.map(function (task) {\n                return task._id === id ? _objectSpread({}, task, {\n                  completed: !task.completed\n                }) : task;\n              } //should refer to state\n              )\n            };\n            break;\n\n          case \"EDIT\":\n            return {\n              tasks: tasks.map(function (task) {\n                return task._id === id ? _objectSpread({}, task, {\n                  description: todo\n                }) : task;\n              })\n            };\n            break;\n\n          default:\n            return null;\n        }\n      } else return null;\n    }\n  }]);\n\n  return TodoList;\n}(PureComponent);\n\nexport default withCookies(withSortedContext(TodoList));","map":null,"metadata":{},"sourceType":"module"}