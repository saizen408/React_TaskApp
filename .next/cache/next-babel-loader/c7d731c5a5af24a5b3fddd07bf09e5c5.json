{"ast":null,"code":"import _Object$defineProperty from \"@babel/runtime-corejs2/core-js/object/define-property\";\nimport _Object$defineProperties from \"@babel/runtime-corejs2/core-js/object/define-properties\";\nimport _Object$getOwnPropertyDescriptors from \"@babel/runtime-corejs2/core-js/object/get-own-property-descriptors\";\nimport _Object$getOwnPropertyDescriptor from \"@babel/runtime-corejs2/core-js/object/get-own-property-descriptor\";\nimport _Object$getOwnPropertySymbols from \"@babel/runtime-corejs2/core-js/object/get-own-property-symbols\";\nimport _Object$keys from \"@babel/runtime-corejs2/core-js/object/keys\";\nimport _toConsumableArray from \"@babel/runtime-corejs2/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"@babel/runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime-corejs2/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _assertThisInitialized from \"@babel/runtime-corejs2/helpers/esm/assertThisInitialized\";\nimport _inherits from \"@babel/runtime-corejs2/helpers/esm/inherits\";\nimport _defineProperty from \"@babel/runtime-corejs2/helpers/esm/defineProperty\";\nvar __jsx = React.createElement;\n\nfunction ownKeys(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (_Object$getOwnPropertyDescriptors) { _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport React, { Component } from \"react\";\nimport DraggableTodoList from \"./DraggableTodoList\";\nimport { withSortedContext } from \"./contexts/SortedContext\";\nimport { Cookies } from \"react-cookie\";\nvar cookies = new Cookies();\n\nvar TodoList =\n/*#__PURE__*/\nfunction (_Component) {\n  _inherits(TodoList, _Component);\n\n  function TodoList(props) {\n    var _this;\n\n    _classCallCheck(this, TodoList);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(TodoList).call(this, props));\n\n    _defineProperty(_assertThisInitialized(_this), \"onSortEnd\", function (_ref) {\n      var oldIndex = _ref.oldIndex,\n          newIndex = _ref.newIndex;\n      var _this$state = _this.state,\n          tasks = _this$state.tasks,\n          prevArr = _this$state.prevArr;\n      console.log(\"before sort: \", prevArr);\n\n      if (prevArr.length === 0) {\n        var arr = cookies.get(\"tasks\"); //if prevArr is same size as state.tasks change nothing\n      } else if (prevArr.length === tasks.length) {\n        var arr = prevArr; //if prev arr is smaller than state.tasks push the new element to the end\n      } else if (prevArr.length < tasks.length) {\n        _this.setState({\n          prevArr: [].concat(_toConsumableArray(prevArr), [tasks[tasks.length - 1]])\n        });\n\n        var arr = prevArr; //if prev arr is larger than state.tasks filter out the corresponding element\n      } else if (prevArr.length > tasks.length) {\n        _this.setState({\n          prevArr: prevArr.filter(function (task) {\n            return task._id !== tasks._id;\n          })\n        });\n\n        var arr = prevArr;\n      } else {\n        return console.log(\"something did not go quite as planned with sorting...\");\n      }\n\n      arr = arr.slice();\n      arr.splice(newIndex < 0 ? arr.length + newIndex : newIndex, 0, arr.splice(oldIndex, 1)[0]);\n      console.log(\"after sort: \", arr);\n\n      _this.setState({\n        tasks: arr,\n        prevArr: arr\n      }); // cookies.set(\"tasks\", this.state.tasks);\n\n    });\n\n    _this.state = {\n      tasks: cookies.get(\"tasks\") || props.posts,\n      prevArr: [],\n      sorted: false,\n      firstId: \"\"\n    };\n    return _this;\n  }\n\n  _createClass(TodoList, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      // if(this.state.tasks.length === 1 && !this.state.tasks[0]._id ) {\n      //   let firstId = cookies.get('taskId')\n      //   this.setState({\n      //     tasks: [\n      //      {\n      //        _id: firstId, //won't get the first addition\n      //        description: this.state.tasks[0].description,\n      //        completed: this.state.tasks[0].completed\n      //      }\n      //    ]\n      //   })\n      // }\n      if (this.state.prevArr.length < this.state.tasks.length) {\n        this.setState({\n          firstId: cookies.get(\"taskId\")\n        });\n      }\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevState) {\n      if (prevState.tasks !== this.state.tasks) {\n        console.log(\"comp did update, set tasks!\");\n        cookies.set(\"tasks\", this.state.tasks);\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var resetSort = this.props.sortedContext.resetSort;\n      var tasks = this.state.tasks;\n      if (tasks.length) return __jsx(DraggableTodoList, {\n        axis: \"y\",\n        distance: 20,\n        onSortEnd: this.onSortEnd,\n        posts: tasks,\n        sorted: resetSort\n      });\n      return null;\n    }\n  }], [{\n    key: \"getDerivedStateFromProps\",\n    value: function getDerivedStateFromProps(props, state) {\n      // if (!state.sorted) { if state.sorted is false\n      var _props$sortedContext$ = props.sortedContext.type,\n          type = _props$sortedContext$.type,\n          id = _props$sortedContext$.id,\n          todo = _props$sortedContext$.todo;\n      var tasks = state.tasks,\n          firstId = state.firstId;\n\n      switch (type) {\n        case \"ADD\":\n          return {\n            tasks: [].concat(_toConsumableArray(tasks), [{\n              _id: firstId,\n              //won't get the first addition\n              description: todo,\n              completed: false\n            }])\n          };\n          break;\n\n        case \"REMOVE\":\n          return {\n            tasks: tasks.filter(function (task) {\n              return task._id !== id;\n            })\n          };\n\n        case \"TOGGLE\":\n          return {\n            tasks: tasks.map(function (task) {\n              return task._id === id ? _objectSpread({}, task, {\n                completed: !task.completed\n              }) : task;\n            })\n          };\n          break;\n\n        case \"EDIT\":\n          return {\n            tasks: tasks.map(function (task) {\n              return task._id === id ? _objectSpread({}, task, {\n                description: todo\n              }) : task;\n            })\n          };\n          break;\n\n        default:\n          return null;\n      } // } else return null;\n\n    }\n  }]);\n\n  return TodoList;\n}(Component);\n\nexport default withSortedContext(TodoList);","map":{"version":3,"sources":["/Users/ericowusu/Documents/React _Course_Projects/Next/first-next/components/TodoList.js"],"names":["React","Component","DraggableTodoList","withSortedContext","Cookies","cookies","TodoList","props","oldIndex","newIndex","state","tasks","prevArr","console","log","length","arr","get","setState","filter","task","_id","slice","splice","posts","sorted","firstId","prevState","set","resetSort","sortedContext","onSortEnd","type","id","todo","description","completed","map"],"mappings":"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","sourcesContent":["import React, { Component } from \"react\";\nimport DraggableTodoList from \"./DraggableTodoList\";\nimport { withSortedContext } from \"./contexts/SortedContext\";\nimport { Cookies } from \"react-cookie\";\nconst cookies = new Cookies();\n\nclass TodoList extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      tasks: cookies.get(\"tasks\") || props.posts,\n      prevArr: [],\n      sorted: false,\n      firstId: \"\"\n    };\n  }\n\n  onSortEnd = ({ oldIndex, newIndex }) => {\n    const { tasks, prevArr } = this.state;\n\n    console.log(\"before sort: \", prevArr);\n    if (prevArr.length === 0) {\n      var arr = cookies.get(\"tasks\");\n      //if prevArr is same size as state.tasks change nothing\n    } else if (prevArr.length === tasks.length) {\n      var arr = prevArr;\n      //if prev arr is smaller than state.tasks push the new element to the end\n    } else if (prevArr.length < tasks.length) {\n      this.setState({\n        prevArr: [...prevArr, tasks[tasks.length - 1]]\n      });\n      var arr = prevArr;\n      //if prev arr is larger than state.tasks filter out the corresponding element\n    } else if (prevArr.length > tasks.length) {\n      this.setState({\n        prevArr: prevArr.filter(task => task._id !== tasks._id)\n      });\n      var arr = prevArr;\n    } else {\n      return console.log(\n        \"something did not go quite as planned with sorting...\"\n      );\n    }\n\n    arr = arr.slice();\n    arr.splice(\n      newIndex < 0 ? arr.length + newIndex : newIndex,\n      0,\n      arr.splice(oldIndex, 1)[0]\n    );\n    console.log(\"after sort: \", arr);\n    this.setState({\n      tasks: arr,\n      prevArr: arr\n    });\n    // cookies.set(\"tasks\", this.state.tasks);\n  };\n\n  componentDidMount() {\n    // if(this.state.tasks.length === 1 && !this.state.tasks[0]._id ) {\n    //   let firstId = cookies.get('taskId')\n    //   this.setState({\n    //     tasks: [\n    //      {\n    //        _id: firstId, //won't get the first addition\n    //        description: this.state.tasks[0].description,\n    //        completed: this.state.tasks[0].completed\n    //      }\n    //    ]\n    //   })\n    // }\n    if (this.state.prevArr.length < this.state.tasks.length) {\n      this.setState({\n        firstId: cookies.get(\"taskId\")\n      });\n    }\n  }\n\n  componentDidUpdate(prevState) {\n    if (prevState.tasks !== this.state.tasks) {\n      console.log(\"comp did update, set tasks!\");\n      cookies.set(\"tasks\", this.state.tasks);\n    }\n  }\n\n  static getDerivedStateFromProps(props, state) {\n    // if (!state.sorted) { if state.sorted is false\n\n    const { type, id, todo } = props.sortedContext.type;\n    const { tasks, firstId } = state;\n\n    switch (type) {\n      case \"ADD\":\n        return {\n          tasks: [\n            ...tasks,\n            {\n              _id: firstId, //won't get the first addition\n              description: todo,\n              completed: false\n            }\n          ]\n        };\n        break;\n      case \"REMOVE\":\n        return { tasks: tasks.filter(task => task._id !== id) };\n      case \"TOGGLE\":\n        return {\n          tasks: tasks.map(task =>\n            task._id === id ? { ...task, completed: !task.completed } : task\n          )\n        };\n        break;\n      case \"EDIT\":\n        return {\n          tasks: tasks.map(task =>\n            task._id === id ? { ...task, description: todo } : task\n          )\n        };\n        break;\n      default:\n        return null;\n    }\n    // } else return null;\n  }\n\n  render() {\n    const { resetSort } = this.props.sortedContext;\n    const { tasks } = this.state;\n    if (tasks.length)\n      return (\n        <DraggableTodoList\n          axis=\"y\"\n          distance={20}\n          onSortEnd={this.onSortEnd}\n          posts={tasks}\n          sorted={resetSort}\n        ></DraggableTodoList>\n      );\n    return null;\n  }\n}\n\nexport default withSortedContext(TodoList);\n"]},"metadata":{},"sourceType":"module"}